<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ª</title>
    <link rel="stylesheet" href="./css/custom.css"> <!-- å¤–éƒ¨CSS -->
    <!-- Google Fonts ã§ Orbitron ãƒ•ã‚©ãƒ³ãƒˆã‚’è¿½åŠ  -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
</head>
<body>

    <header>
        <div class="nav-container">
            <nav>
                <ul>
                    <li><a href="#about">è‡ªå·±ç´¹ä»‹</a></li>
                    <li><a href="#work">ã‚²ãƒ¼ãƒ </a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="hero">
        <div class="hero-content">
            <h1>H e l l o !</h1>
            <p>Webãƒ‡ã‚¶ã‚¤ãƒŠãƒ¼ï¼ˆè¦‹ç¿’ã„ï¼‰ãƒ»é–‹ç™ºè€…ï¼ˆè¦‹ç¿’ã„ï¼‰ | ãƒ‰ã‚¸ã§ã™</p>
            <a href="#work" class="cta-button">ã‚µã‚¤ã‚³ãƒ­ã‚²ãƒ¼ãƒ </a>
        </div>
    </section>

    <section id="about" class="about">
        <h2>ä¸‰æ‘ã§ã™ã€‚</h2>
        <p>æ°—ã¾ã¾ã«è‰²ã€…è§¦ã£ã¦ã¾ã™ã€‚</p>
    </section>

    <section id="work" class="work">
    <style>
        /* ã‚µã‚¤ã‚³ãƒ­ã®æ•°å­—ã‚’å³å´ã«è¡¨ç¤º */
        .dice-container {
            display: flex;
            align-items: center;
        }

        .dice {
            font-size: 50px;
            margin-right: 10px;
        }

        .dice-number {
            font-size: 30px;
            font-weight: bold;
        }

        .game-button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 10px;
        }

        .result-section {
            margin-top: 20px;
        }

        .game-container {
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- ã‚µã‚¤ã‚³ãƒ­ã‚²ãƒ¼ãƒ  -->
    <section id="game" class="work">
        <div class="game-container">
            <h3>ğŸ² ã‚µã‚¤ã‚³ãƒ­ã‚²ãƒ¼ãƒ  ğŸ²</h3>
            <p>2äººã§ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã£ã¦å‹è² ã—ã‚ˆã†ï¼</p>

            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Aã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="player-section">
                <h4>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼A</h4>
                <div class="dice-container">
                    <div id="playerA-dice" class="dice">ğŸ²</div>
                    <div id="playerA-number" class="dice-number">0</div>
                </div>
                <button id="playerA-roll" class="game-button">ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹</button>
            </div>

            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Bã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ -->
            <div class="player-section">
                <h4>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼B</h4>
                <div class="dice-container">
                    <div id="playerB-dice" class="dice">ğŸ²</div>
                    <div id="playerB-number" class="dice-number">0</div>
                </div>
                <button id="playerB-roll" class="game-button" disabled>ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹</button>
            </div>

            <!-- å‹æ•—è¡¨ç¤ºã¨ã‚¹ã‚³ã‚¢ -->
            <div class="result-section">
                <h4 id="result-message">å‹è² ã®çµæœ: ???</h4>
                <p>ã‚¹ã‚³ã‚¢: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼A <span id="playerA-score">0</span> - <span id="playerB-score">0</span> ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼B</p>
                <button id="reset-game" class="game-button">ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>
    </section>

    <!-- ãƒ¢ã‚°ãƒ©å©ãã‚²ãƒ¼ãƒ  -->
    <section id="whack-a-mole" class="work">
        <div class="game-container">
            <h3>ğŸ¹ ãƒ¢ã‚°ãƒ©å©ãã‚²ãƒ¼ãƒ  ğŸ¹</h3>
            <p>ãƒ¢ã‚°ãƒ©ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å¾—ç‚¹ã‚’ç¨¼ã”ã†ï¼</p>
            <div id="mole-container" class="mole-container">
                <!-- ãƒ¢ã‚°ãƒ©ã®ç©´ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            </div>
            <p>ã‚¹ã‚³ã‚¢: <span id="score">0</span></p>
            <p>æ®‹ã‚Šæ™‚é–“: <span id="time">10</span>ç§’</p>
            <button id="start-game" class="game-button">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
            <h4>ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢</h4>
            <ul id="best-scores">
                <!-- ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™ -->
            </ul>
        </div>
    </section>

    <!-- ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ã‚²ãƒ¼ãƒ  -->
    <section id="minesweeper" class="work">
    <div class="game-container">
        <h3>ğŸ’£ ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ ğŸ’£</h3>
        <p>åœ°é›·ã‚’é¿ã‘ã¦ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’é–‹ã‘ã‚ˆã†ï¼</p>
        <div id="minesweeper-container" class="minesweeper-container">
            <!-- ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ã®ã‚»ãƒ«ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
        </div>
        <p>åœ°é›·ã®ç·æ•°: <span id="mine-count">0</span></p>
        <button id="reset-minesweeper" class="game-button">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
</section>

<!-- æ•°ç‹¬ã‚²ãƒ¼ãƒ  -->
<section id="sudoku" class="work">
    <div class="game-container">
        <h3>ğŸ§© æ•°ç‹¬ã‚²ãƒ¼ãƒ  ğŸ§©</h3>
        <p>æ•°ç‹¬ã‚’è§£ã„ã¦ã¿ã‚ˆã†ï¼</p>
        <div id="sudoku-container" class="sudoku-container">
            <!-- æ•°ç‹¬ã®ã‚»ãƒ«ãŒã“ã“ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
        </div>
        <button id="toggle-memo" class="game-button">ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰</button>
        <button id="reset-sudoku" class="game-button">ãƒªã‚»ãƒƒãƒˆ</button>
    </div>
</section>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        const minesweeperContainer = document.getElementById("minesweeper-container");
        const resetMinesweeperButton = document.getElementById("reset-minesweeper");
        const mineCountDisplay = document.getElementById("mine-count");
        const rows = 10;
        const cols = 10;
        let minesCount = 9; // æœ€å¤§9å€‹ã®åœ°é›·
        let minesweeperGrid = [];
        let gameOver = false;

        // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ã®ã‚»ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createMinesweeperGrid() {
            minesweeperContainer.innerHTML = "";
            minesweeperGrid = [];
            gameOver = false;

            // åœ°é›·ã®æ•°ã‚’è¨­å®š
            minesCount = Math.floor(Math.random() * 9) + 1; // 1ã‹ã‚‰9ã®é–“ã§ãƒ©ãƒ³ãƒ€ãƒ 
            mineCountDisplay.textContent = minesCount;

            for (let row = 0; row < rows; row++) {
                const rowArray = [];
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement("div");
                    cell.classList.add("minesweeper-cell");
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.addEventListener("click", () => openCell(row, col));
                    minesweeperContainer.appendChild(cell);
                    rowArray.push({ element: cell, mine: false, opened: false, flagged: false });
                }
                minesweeperGrid.push(rowArray);
            }

            // åœ°é›·ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
            let minesPlaced = 0;
            while (minesPlaced < minesCount) {
                const randomRow = Math.floor(Math.random() * rows);
                const randomCol = Math.floor(Math.random() * cols);
                if (!minesweeperGrid[randomRow][randomCol].mine) {
                    minesweeperGrid[randomRow][randomCol].mine = true;
                    minesPlaced++;
                }
            }
        }

        // ã‚»ãƒ«ã‚’é–‹ã‘ã‚‹é–¢æ•°
        function openCell(row, col) {
            if (gameOver || minesweeperGrid[row][col].opened) return;

            const cell = minesweeperGrid[row][col];
            cell.opened = true;
            cell.element.classList.add("opened");

            if (cell.mine) {
                cell.element.classList.add("mine");
                gameOver = true;
                alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼åœ°é›·ã‚’è¸ã¿ã¾ã—ãŸï¼");
                revealMines();
                return;
            }

            const adjacentMines = countAdjacentMines(row, col);
            if (adjacentMines > 0) {
                cell.element.textContent = adjacentMines;
            } else {
                // å‘¨å›²ã«åœ°é›·ãŒãªã„å ´åˆã¯éš£æ¥ã™ã‚‹ã‚»ãƒ«ã‚‚é–‹ã‘ã‚‹
                openAdjacentCells(row, col);
            }

            checkWin();
        }

        // å‘¨å›²ã®åœ°é›·ã®æ•°ã‚’æ•°ãˆã‚‹é–¢æ•°
        function countAdjacentMines(row, col) {
            let count = 0;
            for (let r = -1; r <= 1; r++) {
                for (let c = -1; c <= 1; c++) {
                    const newRow = row + r;
                    const newCol = col + c;
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && minesweeperGrid[newRow][newCol].mine) {
                        count++;
                    };
                }
            }
            return count;
        }

        // éš£æ¥ã™ã‚‹ã‚»ãƒ«ã‚’é–‹ã‘ã‚‹é–¢æ•°
        function openAdjacentCells(row, col) {
            for (let r = -1; r <= 1; r++) {
                for (let c = -1; c <= 1; c++) {
                    const newRow = row + r;
                    const newCol = col + c;
                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !minesweeperGrid[newRow][newCol].opened) {
                        openCell(newRow, newCol);
                    }
                }
            }
        }

        // åœ°é›·ã‚’ã™ã¹ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
        function revealMines() {
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (minesweeperGrid[row][col].mine) {
                        minesweeperGrid[row][col].element.classList.add("mine");
                    }
                }
            }
        }

        // å‹åˆ©ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function checkWin() {
            let openedCells = 0;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (minesweeperGrid[row][col].opened) {
                        openedCells++;
                    }
                }
            }
            if (openedCells === rows * cols - minesCount) {
                alert("ãŠã‚ã§ã¨ã†ï¼ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’é–‹ã‘ã¾ã—ãŸï¼");
                gameOver = true;
                revealMines();
            }
        }

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        resetMinesweeperButton.addEventListener("click", createMinesweeperGrid);

        // åˆæœŸè¨­å®š
        createMinesweeperGrid();
    });

    document.addEventListener("DOMContentLoaded", function() {
        const sudokuContainer = document.getElementById("sudoku-container");
        const resetSudokuButton = document.getElementById("reset-sudoku");
        const toggleMemoButton = document.getElementById("toggle-memo");
        const size = 9;
        let sudokuGrid = [];
        let memoMode = false;

        // æ•°ç‹¬ã®ã‚»ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createSudokuGrid() {
            sudokuContainer.innerHTML = "";
            sudokuGrid = [];

            for (let row = 0; row < size; row++) {
                const rowArray = [];
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement("div");
                    cell.classList.add("sudoku-cell");
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.contentEditable = true;
                    cell.addEventListener("input", () => validateCell(row, col));
                    sudokuContainer.appendChild(cell);
                    rowArray.push(cell);
                }
                sudokuGrid.push(rowArray);
            }

            // æ•°ç‹¬ã®åˆæœŸé…ç½®ã‚’è¨­å®š
            setInitialSudokuValues();
        }

        // æ•°ç‹¬ã®åˆæœŸé…ç½®ã‚’è¨­å®šã™ã‚‹é–¢æ•°
        function setInitialSudokuValues() {
            const initialValuesList = [
                [
                    [5, 3, null, null, 7, null, null, null, null],
                    [6, null, null, 1, 9, 5, null, null, null],
                    [null, 9, 8, null, null, null, null, 6, null],
                    [8, null, null, null, 6, null, null, null, 3],
                    [4, null, null, 8, null, 3, null, null, 1],
                    [7, null, null, null, 2, null, null, null, 6],
                    [null, 6, null, null, null, null, 2, 8, null],
                    [null, null, null, 4, 1, 9, null, null, 5],
                    [null, null, null, null, 8, null, null, 7, 9]
                ],
                [
                    [null, null, null, 2, 6, null, 7, null, 1],
                    [6, 8, null, null, 7, null, null, 9, null],
                    [1, 9, null, null, null, 4, 5, null, null],
                    [8, 2, null, 1, null, null, null, 4, null],
                    [null, null, 4, 6, null, 2, 9, null, null],
                    [null, 5, null, null, null, 3, null, 2, 8],
                    [null, null, 9, 3, null, null, null, 7, 4],
                    [null, 4, null, null, 5, null, null, 3, 6],
                    [7, null, 3, null, 1, 8, null, null, null]
                ],
                [
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null]
                ]
            ];

            const initialValues = initialValuesList[Math.floor(Math.random() * initialValuesList.length)];

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (initialValues[row][col] !== null) {
                        sudokuGrid[row][col].textContent = initialValues[row][col];
                        sudokuGrid[row][col].contentEditable = false;
                    }
                }
            }
        }

        // ã‚»ãƒ«ã®å…¥åŠ›ã‚’æ¤œè¨¼ã™ã‚‹é–¢æ•°
        function validateCell(row, col) {
            const cell = sudokuGrid[row][col];
            const value = cell.textContent.trim();

            if (memoMode) {
                cell.classList.add("memo");
            } else {
                cell.classList.remove("memo");
                if (!/^[1-9]$/.test(value)) {
                    cell.textContent = "";
                    return;
                }

                // è¡Œã€åˆ—ã€ãƒ–ãƒ­ãƒƒã‚¯ã®é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
                if (!isValidSudoku(row, col, value)) {
                    cell.classList.add("invalid");
                } else {
                    cell.classList.remove("invalid");
                    checkWin();
                }
            }
        }

        // æ•°ç‹¬ã®æœ‰åŠ¹æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function isValidSudoku(row, col, value) {
            // è¡Œã®ãƒã‚§ãƒƒã‚¯
            for (let c = 0; c < size; c++) {
                if (c !== col && sudokuGrid[row][c].textContent.trim() === value) {
                    return false;
                }
            }

            // åˆ—ã®ãƒã‚§ãƒƒã‚¯
            for (let r = 0; r < size; r++) {
                if (r !== row && sudokuGrid[r][col].textContent.trim() === value) {
                    return false;
                }
            }

            // ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚§ãƒƒã‚¯
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if ((r !== row || c !== col) && sudokuGrid[r][c].textContent.trim() === value) {
                        return false;
                    }
                }
            }

            return true;
        }

        // æ•°ç‹¬ãŒã‚¯ãƒªã‚¢ã•ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function checkWin() {
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = sudokuGrid[row][col];
                    const value = cell.textContent.trim();
                    if (!/^[1-9]$/.test(value) || !isValidSudoku(row, col, value)) {
                        return;
                    }
                }
            }
            // ã‚¯ãƒªã‚¢æ™‚ã®æ¼”å‡º
            alert("ãŠã‚ã§ã¨ã†ï¼æ•°ç‹¬ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼");
            sudokuContainer.classList.add("sudoku-completed");
        }

        // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        toggleMemoButton.addEventListener("click", function() {
            memoMode = !memoMode;
            toggleMemoButton.textContent = memoMode ? "ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: ON" : "ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: OFF";
        });

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        resetSudokuButton.addEventListener("click", function() {
            sudokuContainer.classList.remove("sudoku-completed");
            createSudokuGrid();
        });

        // åˆæœŸè¨­å®š
        createSudokuGrid();
    });
</script>

    <!-- JavaScript -->
    <script>
        let playerAScore = 0;
        let playerBScore = 0;
        let playerAWinCount = 0;
        let playerBWinCount = 0;

        const playerARollButton = document.getElementById("playerA-roll");
        const playerBRollButton = document.getElementById("playerB-roll");
        const playerADice = document.getElementById("playerA-dice");
        const playerBDice = document.getElementById("playerB-dice");
        const playerANumber = document.getElementById("playerA-number");
        const playerBNumber = document.getElementById("playerB-number");
        const resultMessage = document.getElementById("result-message");
        const playerAScoreDisplay = document.getElementById("playerA-score");
        const playerBScoreDisplay = document.getElementById("playerB-score");
        const resetButton = document.getElementById("reset-game");

        let playerAResult = 0;
        let playerBResult = 0;

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼AãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹
        playerARollButton.addEventListener("click", function() {
            if (playerAWinCount >= 3 || playerBWinCount >= 3) {
                return; // ã™ã§ã«ã©ã¡ã‚‰ã‹ãŒ3å›å‹ã£ãŸã‚‰ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Œãªã„
            }
            playerAResult = Math.floor(Math.random() * 6) + 1;
            playerADice.textContent = `ğŸ²`;
            playerANumber.textContent = playerAResult;
            playerADice.classList.add("roll-animation");

            // æ¬¡ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Bã®ç•ª
            playerARollButton.disabled = true;
            playerBRollButton.disabled = false;

            setTimeout(() => playerADice.classList.remove("roll-animation"), 500);
        });

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼BãŒã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚‹
        playerBRollButton.addEventListener("click", function() {
            if (playerAWinCount >= 3 || playerBWinCount >= 3) {
                return; // ã™ã§ã«ã©ã¡ã‚‰ã‹ãŒ3å›å‹ã£ãŸã‚‰ã‚µã‚¤ã‚³ãƒ­ã‚’æŒ¯ã‚Œãªã„
            }
            playerBResult = Math.floor(Math.random() * 6) + 1;
            playerBDice.textContent = `ğŸ²`;
            playerBNumber.textContent = playerBResult;
            playerBDice.classList.add("roll-animation");

            // å‹æ•—ã‚’åˆ¤å®š
            setTimeout(() => {
                determineWinner();
                playerBRollButton.disabled = true;
            }, 500);
        });

        // å‹æ•—ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
        function determineWinner() {
            if (playerAResult > playerBResult) {
                resultMessage.textContent = "å‹è² ã®çµæœ: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Aã®å‹ã¡ï¼ğŸ‰";
                playerAWinCount++;
            } else if (playerBResult > playerAResult) {
                resultMessage.textContent = "å‹è² ã®çµæœ: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Bã®å‹ã¡ï¼ğŸ‰";
                playerBWinCount++;
            } else {
                resultMessage.textContent = "å¼•ãåˆ†ã‘ï¼ã‚‚ã†ä¸€åº¦æŒ¯ã‚ã†ï¼";
            }
            updateScores();
            checkGameOver();
            resetRound();
        }

        // ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
        function updateScores() {
            playerAScoreDisplay.textContent = playerAWinCount;
            playerBScoreDisplay.textContent = playerBWinCount;
        }

        // ã‚²ãƒ¼ãƒ çµ‚äº†ã®åˆ¤å®š
        function checkGameOver() {
            if (playerAWinCount >= 3) {
                resultMessage.textContent = "ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Aã®å‹ã¡ã§ã™ï¼ğŸ‰";
                playerARollButton.disabled = true;
                playerBRollButton.disabled = true;
            } else if (playerBWinCount >= 3) {
                resultMessage.textContent = "ã‚²ãƒ¼ãƒ çµ‚äº†ï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Bã®å‹ã¡ã§ã™ï¼ğŸ‰";
                playerARollButton.disabled = true;
                playerBRollButton.disabled = true;
            }
        }

        // æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹é–¢æ•°
        function resetRound() {
            playerARollButton.disabled = false;
            playerBRollButton.disabled = true;
            playerADice.textContent = "ğŸ²";
            playerBDice.textContent = "ğŸ²";
            playerANumber.textContent = "0";
            playerBNumber.textContent = "0";
        }

        // ã‚²ãƒ¼ãƒ å…¨ä½“ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
        resetButton.addEventListener("click", function() {
            playerAWinCount = 0;
            playerBWinCount = 0;
            resultMessage.textContent = "å‹è² ã®çµæœ: ???";
            updateScores();
            resetRound();
            playerARollButton.disabled = false;
            playerBRollButton.disabled = true;
        });

        document.addEventListener("DOMContentLoaded", function() {
            const moleContainer = document.getElementById("mole-container");
            const startGameButton = document.getElementById("start-game");
            const scoreDisplay = document.getElementById("score");
            const timeDisplay = document.getElementById("time");
            const bestScoresList = document.getElementById("best-scores");
            let score = 0;
            let activeMole = null;
            let gameInterval = null;
            let countdownInterval = null;
            let timeLeft = 10;
            let bestScores = [];
            let moleIntervalTime = 1000; // ãƒ¢ã‚°ãƒ©ã®å‡ºç¾é–“éš”

            // ãƒ¢ã‚°ãƒ©ã®ç©´ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createMoleHoles() {
                for (let i = 0; i < 9; i++) {
                    const moleHole = document.createElement("div");
                    moleHole.classList.add("mole-hole");
                    moleHole.addEventListener("click", () => hitMole(i));
                    moleContainer.appendChild(moleHole);
                }
            }

            // ãƒ¢ã‚°ãƒ©ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function showMole() {
                if (activeMole !== null) {
                    moleContainer.children[activeMole].classList.remove("active");
                }
                const randomIndex = Math.floor(Math.random() * 9);
                moleContainer.children[randomIndex].classList.add("active");
                activeMole = randomIndex;
            }

            // ãƒ¢ã‚°ãƒ©ã‚’å©ã„ãŸã¨ãã®å‡¦ç†
            function hitMole(index) {
                if (index === activeMole) {
                    score++;
                    scoreDisplay.textContent = score;
                    moleContainer.children[activeMole].classList.remove("active");
                    activeMole = null;
                    // ãƒ¢ã‚°ãƒ©ã®å‡ºç¾é–“éš”ã‚’çŸ­ãã™ã‚‹
                    moleIntervalTime = Math.max(200, moleIntervalTime - 100);
                    clearInterval(gameInterval);
                    gameInterval = setInterval(showMole, moleIntervalTime);
                }
            }

            // ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°
            function startGame() {
                score = 0;
                scoreDisplay.textContent = score;
                timeLeft = 10;
                timeDisplay.textContent = timeLeft;
                moleIntervalTime = 1000; // åˆæœŸã®ãƒ¢ã‚°ãƒ©ã®å‡ºç¾é–“éš”
                gameInterval = setInterval(showMole, moleIntervalTime);
                countdownInterval = setInterval(countdown, 1000);
            }

            // ã‚²ãƒ¼ãƒ ã‚’åœæ­¢ã™ã‚‹é–¢æ•°
            function stopGame() {
                clearInterval(gameInterval);
                clearInterval(countdownInterval);
                if (activeMole !== null) {
                    moleContainer.children[activeMole].classList.remove("active");
                    activeMole = null;
                }
                updateBestScores();
            }

            // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚’è¡Œã†é–¢æ•°
            function countdown() {
                timeLeft--;
                timeDisplay.textContent = timeLeft;
                if (timeLeft <= 0) {
                    stopGame();
                }
            }

            // ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateBestScores() {
                bestScores.push(score);
                bestScores.sort((a, b) => b - a);
                if (bestScores.length > 5) {
                    bestScores.pop();
                }
                renderBestScores();
            }

            // ãƒ™ã‚¹ãƒˆã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function renderBestScores() {
                bestScoresList.innerHTML = "";
                bestScores.forEach((score, index) => {
                    const li = document.createElement("li");
                    li.textContent = `${index + 1}. ${score}ç‚¹`;
                    bestScoresList.appendChild(li);
                });
            }

            // ã‚¹ã‚¿ãƒ¼ãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            startGameButton.addEventListener("click", function() {
                stopGame();
                startGame();
            });

            // åˆæœŸè¨­å®š
            createMoleHoles();
        });

        document.addEventListener("DOMContentLoaded", function() {
            const minesweeperContainer = document.getElementById("minesweeper-container");
            const resetMinesweeperButton = document.getElementById("reset-minesweeper");
            const mineCountDisplay = document.getElementById("mine-count");
            const rows = 10;
            const cols = 10;
            let minesCount = 9; // æœ€å¤§9å€‹ã®åœ°é›·
            let minesweeperGrid = [];
            let gameOver = false;

            // ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ã®ã‚»ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
            function createMinesweeperGrid() {
                minesweeperContainer.innerHTML = "";
                minesweeperGrid = [];
                gameOver = false;

                // åœ°é›·ã®æ•°ã‚’è¨­å®š
                minesCount = Math.floor(Math.random() * 9) + 1; // 1ã‹ã‚‰9ã®é–“ã§ãƒ©ãƒ³ãƒ€ãƒ 
                mineCountDisplay.textContent = minesCount;

                for (let row = 0; row < rows; row++) {
                    const rowArray = [];
                    for (let col = 0; col < cols; col++) {
                        const cell = document.createElement("div");
                        cell.classList.add("minesweeper-cell");
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener("click", () => openCell(row, col));
                        minesweeperContainer.appendChild(cell);
                        rowArray.push({ element: cell, mine: false, opened: false, flagged: false });
                    }
                    minesweeperGrid.push(rowArray);
                }

                // åœ°é›·ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
                let minesPlaced = 0;
                while (minesPlaced < minesCount) {
                    const randomRow = Math.floor(Math.random() * rows);
                    const randomCol = Math.floor(Math.random() * cols);
                    if (!minesweeperGrid[randomRow][randomCol].mine) {
                        minesweeperGrid[randomRow][randomCol].mine = true;
                        minesPlaced++;
                    }
                }
            }

            // ã‚»ãƒ«ã‚’é–‹ã‘ã‚‹é–¢æ•°
            function openCell(row, col) {
                if (gameOver || minesweeperGrid[row][col].opened) return;

                const cell = minesweeperGrid[row][col];
                cell.opened = true;
                cell.element.classList.add("opened");

                if (cell.mine) {
                    cell.element.classList.add("mine");
                    gameOver = true;
                    alert("ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼åœ°é›·ã‚’è¸ã¿ã¾ã—ãŸï¼");
                    revealMines();
                    return;
                }

                const adjacentMines = countAdjacentMines(row, col);
                if (adjacentMines > 0) {
                    cell.element.textContent = adjacentMines;
                } else {
                    // å‘¨å›²ã«åœ°é›·ãŒãªã„å ´åˆã¯éš£æ¥ã™ã‚‹ã‚»ãƒ«ã‚‚é–‹ã‘ã‚‹
                    openAdjacentCells(row, col);
                }

                checkWin();
            }

            // å‘¨å›²ã®åœ°é›·ã®æ•°ã‚’æ•°ãˆã‚‹é–¢æ•°
            function countAdjacentMines(row, col) {
                let count = 0;
                for (let r = -1; r <= 1; r++) {
                    for (let c = -1; c <= 1; c++) {
                        const newRow = row + r;
                        const newCol = col + c;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && minesweeperGrid[newRow][newCol].mine) {
                            count++;
                        };
                    }
                }
                return count;
            }

            // éš£æ¥ã™ã‚‹ã‚»ãƒ«ã‚’é–‹ã‘ã‚‹é–¢æ•°
            function openAdjacentCells(row, col) {
                for (let r = -1; r <= 1; r++) {
                    for (let c = -1; c <= 1; c++) {
                        const newRow = row + r;
                        const newCol = col + c;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !minesweeperGrid[newRow][newCol].opened) {
                            openCell(newRow, newCol);
                        }
                    }
                }
            }

            // åœ°é›·ã‚’ã™ã¹ã¦è¡¨ç¤ºã™ã‚‹é–¢æ•°
            function revealMines() {
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (minesweeperGrid[row][col].mine) {
                            minesweeperGrid[row][col].element.classList.add("mine");
                        }
                    }
                }
            }

            // å‹åˆ©ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
            function checkWin() {
                let openedCells = 0;
                for (let row = 0; row < rows; row++) {
                    for (let col = 0; col < cols; col++) {
                        if (minesweeperGrid[row][col].opened) {
                            openedCells++;
                        }
                    }
                }
                if (openedCells === rows * cols - minesCount) {
                    alert("ãŠã‚ã§ã¨ã†ï¼ã™ã¹ã¦ã®ã‚»ãƒ«ã‚’é–‹ã‘ã¾ã—ãŸï¼");
                    gameOver = true;
                    revealMines();
                }
            }

            // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            resetMinesweeperButton.addEventListener("click", createMinesweeperGrid);

            // åˆæœŸè¨­å®š
            createMinesweeperGrid();
        });

        document.addEventListener("DOMContentLoaded", function() {
        const sudokuContainer = document.getElementById("sudoku-container");
        const resetSudokuButton = document.getElementById("reset-sudoku");
        const toggleMemoButton = document.getElementById("toggle-memo");
        const size = 9;
        let sudokuGrid = [];
        let memoMode = false;

        // æ•°ç‹¬ã®ã‚»ãƒ«ã‚’ä½œæˆã™ã‚‹é–¢æ•°
        function createSudokuGrid() {
            sudokuContainer.innerHTML = "";
            sudokuGrid = [];

            for (let row = 0; row < size; row++) {
                const rowArray = [];
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement("div");
                    cell.classList.add("sudoku-cell");
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.contentEditable = true;
                    cell.addEventListener("input", () => validateCell(row, col));
                    sudokuContainer.appendChild(cell);
                    rowArray.push(cell);
                }
                sudokuGrid.push(rowArray);
            }

            // æ•°ç‹¬ã®åˆæœŸé…ç½®ã‚’è¨­å®š
            setInitialSudokuValues();
        }

        // æ•°ç‹¬ã®åˆæœŸé…ç½®ã‚’è¨­å®šã™ã‚‹é–¢æ•°
        function setInitialSudokuValues() {
            const initialValuesList = [
                [
                    [5, 3, null, null, 7, null, null, null, null],
                    [6, null, null, 1, 9, 5, null, null, null],
                    [null, 9, 8, null, null, null, null, 6, null],
                    [8, null, null, null, 6, null, null, null, 3],
                    [4, null, null, 8, null, 3, null, null, 1],
                    [7, null, null, null, 2, null, null, null, 6],
                    [null, 6, null, null, null, null, 2, 8, null],
                    [null, null, null, 4, 1, 9, null, null, 5],
                    [null, null, null, null, 8, null, null, 7, 9]
                ],
                [
                    [null, null, null, 2, 6, null, 7, null, 1],
                    [6, 8, null, null, 7, null, null, 9, null],
                    [1, 9, null, null, null, 4, 5, null, null],
                    [8, 2, null, 1, null, null, null, 4, null],
                    [null, null, 4, 6, null, 2, 9, null, null],
                    [null, 5, null, null, null, 3, null, 2, 8],
                    [null, null, 9, 3, null, null, null, 7, 4],
                    [null, 4, null, null, 5, null, null, 3, 6],
                    [7, null, 3, null, 1, 8, null, null, null]
                ],
                [
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null],
                    [null, null, null, null, null, null, null, null, null]
                ]
            ];

            const initialValues = initialValuesList[Math.floor(Math.random() * initialValuesList.length)];

            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (initialValues[row][col] !== null) {
                        sudokuGrid[row][col].textContent = initialValues[row][col];
                        sudokuGrid[row][col].contentEditable = false;
                    }
                }
            }
        }

        // ã‚»ãƒ«ã®å…¥åŠ›ã‚’æ¤œè¨¼ã™ã‚‹é–¢æ•°
        function validateCell(row, col) {
            const cell = sudokuGrid[row][col];
            const value = cell.textContent.trim();

            if (memoMode) {
                cell.classList.add("memo");
            } else {
                cell.classList.remove("memo");
                if (!/^[1-9]$/.test(value)) {
                    cell.textContent = "";
                    return;
                }

                // è¡Œã€åˆ—ã€ãƒ–ãƒ­ãƒƒã‚¯ã®é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯
                if (!isValidSudoku(row, col, value)) {
                    cell.classList.add("invalid");
                } else {
                    cell.classList.remove("invalid");
                    checkWin();
                }
            }
        }

        // æ•°ç‹¬ã®æœ‰åŠ¹æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function isValidSudoku(row, col, value) {
            // è¡Œã®ãƒã‚§ãƒƒã‚¯
            for (let c = 0; c < size; c++) {
                if (c !== col && sudokuGrid[row][c].textContent.trim() === value) {
                    return false;
                }
            }

            // åˆ—ã®ãƒã‚§ãƒƒã‚¯
            for (let r = 0; r < size; r++) {
                if (r !== row && sudokuGrid[r][col].textContent.trim() === value) {
                    return false;
                }
            }

            // ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒã‚§ãƒƒã‚¯
            const startRow = Math.floor(row / 3) * 3;
            const startCol = Math.floor(col / 3) * 3;
            for (let r = startRow; r < startRow + 3; r++) {
                for (let c = startCol; c < startCol + 3; c++) {
                    if ((r !== row || c !== col) && sudokuGrid[r][c].textContent.trim() === value) {
                        return false;
                    }
                }
            }

            return true;
        }

        // æ•°ç‹¬ãŒã‚¯ãƒªã‚¢ã•ã‚ŒãŸã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹é–¢æ•°
        function checkWin() {
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = sudokuGrid[row][col];
                    const value = cell.textContent.trim();
                    if (!/^[1-9]$/.test(value) || !isValidSudoku(row, col, value)) {
                        return;
                    }
                }
            }
            // ã‚¯ãƒªã‚¢æ™‚ã®æ¼”å‡º
            alert("ãŠã‚ã§ã¨ã†ï¼æ•°ç‹¬ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸï¼");
            sudokuContainer.classList.add("sudoku-completed");
        }

        // ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰ã®åˆ‡ã‚Šæ›¿ãˆ
        toggleMemoButton.addEventListener("click", function() {
            memoMode = !memoMode;
            toggleMemoButton.textContent = memoMode ? "ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: ON" : "ãƒ¡ãƒ¢ãƒ¢ãƒ¼ãƒ‰: OFF";
        });

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        resetSudokuButton.addEventListener("click", function() {
            sudokuContainer.classList.remove("sudoku-completed");
            createSudokuGrid();
        });

        // åˆæœŸè¨­å®š
        createSudokuGrid();
    });
    </script>

</body>
</html>
